const std = @import("std");
const builtin = @import("builtin");


pub fn generateHeaders(b: *std.Build, build_path: *[]const u8) void {
    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
    std.mem.copyForwards(u8, buf[0..], build_path.*);
    std.debug.print("Saving headers in {s}\n", .{buf[0..build_path.len]});

    const popcnt = if (std.Target.x86.featureSetHas(builtin.cpu.features, .popcnt)) "1" else "0";
    const sse4 = if (std.Target.x86.featureSetHas(builtin.cpu.features, .sse4_2)) "1" else "0";
    const ssse3 = if (std.Target.x86.featureSetHas(builtin.cpu.features, .ssse3)) "1" else "0";
    const avx2 = if (std.Target.x86.featureSetHas(builtin.cpu.features, .avx2)) "1" else "0";
    const avx512 = if (std.Target.x86.featureSetHas(builtin.cpu.features, .avx512f)) "1" else "0";

    //config.h
    var hdr_path: []const u8 = "/config.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genConfigFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    defer genConfigFile.close();
    const writer = genConfigFile.writer();
    writer.print(
    \\ /* Default config.h generated by build.zig */
    \\#define HAVE_LIBBZ2 1
    \\#define HAVE_LIBLZMA 1
    \\#ifndef __APPLE__
    \\#define HAVE_LZMA_H 1
    \\#endif
    \\#define HAVE_DRAND48 1
    \\#define HAVE_LIBCURL 1
    \\#define HAVE_POPCNT {s}
    \\#define HAVE_SSE4_1 {s}
    \\#define HAVE_SSSE3 {s}
    \\#define HAVE_AVX2 {s}
    \\#define HAVE_AVX512 {s}
    \\#define UBSAN 0
    , .{popcnt, sse4, ssse3, avx2, avx512}) catch unreachable;

    //config_vars.h
    hdr_path = "/config_vars.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genVarsFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    const vars_writer = genVarsFile.writer();
    const CPPFLAGS: []const u8 = b.graph.env_map.get("CPPFLAGS") orelse "";
    const CFLAGS: []const u8 = b.graph.env_map.get("CFLAGS") orelse "";
    const LDFLAGS: []const u8 = b.graph.env_map.get("LDFLAGS") orelse "";
    const LIBS: []const u8 = b.graph.env_map.get("LIBS") orelse "";
    vars_writer.print(
    \\#define HTS_CC "zig cc"
    \\#define HTS_CPPFLAGS "{s}"
    \\#define HTS_CFLAGS "{s} -g -Wall -O2 -fvisibility=hidden -fpic"
    \\#define HTS_LDFLAGS "{s} -fvisibility=hidden "
    \\#define HTS_LIBS "{s} -lz -lm -lbz2 -llzma -lcurl -lpthread"
    , .{CPPFLAGS, CFLAGS, LDFLAGS, LIBS}) catch unreachable;

    // version.h
    const hts_version = "1.19.1";
    hdr_path = "/version.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genVerFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    const ver_writer = genVerFile.writer();
    ver_writer.print(
    \\#define HTS_VERSION_TEXT "{s}"
    , .{hts_version}) catch unreachable;
}

pub fn build(b: *std.Build) void {

    const LIBHTS_SOVERSION = 3;

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = std.builtin.OptimizeMode.ReleaseFast });

    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();
    const arena = arena_state.allocator();

    var cflags = std.ArrayList([]const u8).init(arena);
    defer cflags.deinit();

    // First build libdeflate
    //-----------------------
    // const libdeflate = b.addStaticLibrary(.{
    //     .name = "deflate",
    //     .target = target,
    //     .optimize = optimize,
    // });
    //
    //
    // cflags.append("-O2") catch unreachable;
    // cflags.append("-DNDEBUG") catch unreachable;
    // cflags.append("-Wall") catch unreachable;
    // cflags.append("-Wdeclaration-after-statement") catch unreachable;
    // cflags.append("-Wimplicit-fallthrough") catch unreachable;
    // cflags.append("-Wmissing-field-initializers") catch unreachable;
    // cflags.append("-Wmissing-prototypes") catch unreachable;
    // cflags.append("-Wpedantic") catch unreachable;
    // cflags.append("-Wshadow") catch unreachable;
    // cflags.append("-Wstrict-prototypes") catch unreachable;
    // cflags.append("-Wundef") catch unreachable;
    // cflags.append("-Wvla") catch unreachable;
    //
    // const libdeflate_src_files = &[_][]const u8{
    //     "libdeflate/lib/deflate_compress.c",
    //     "libdeflate/lib/deflate_decompress.c",
    //     "libdeflate/lib/adler32.c",
    //     "libdeflate/lib/zlib_compress.c",
    //     "libdeflate/lib/zlib_decompress.c",
    //     "libdeflate/lib/crc32.c",
    //     "libdeflate/lib/gzip_compress.c",
    //     "libdeflate/lib/gzip_decompress.c",
    //     "libdeflate/lib/utils.c",
    // };
    // std.debug.print("YO\n", .{});
    // if (builtin.zig_backend == .stage2_x86) {
    //     std.debug.print("YOO\n", .{});
    // } else if (builtin.zig_backend == .stage2_aarch64) {
    //     std.debug.print("YOO2\n", .{});
    // }
    //
    // for (libdeflate_src_files) |file| {
    //     libdeflate.addCSourceFile(.{
    //     .file = .{.path = file},
    //     .flags = cflags.items,
    //     });
    // }
    //
    // libdeflate.addIncludePath(.{ .path = "libdeflate" });
    // libdeflate.addIncludePath(.{ .path = "libdeflate/lib" });
    // libdeflate.addIncludePath(.{ .path = "libdeflate/lib/arm" });
    // libdeflate.addIncludePath(.{ .path = "libdeflate/lib/x86" });
    //
    //
    // libdeflate.linkLibC();

    // _ = libdeflate;

    // Now build htslib
    //-----------------

    cflags.clearAndFree();
    cflags.append("-g") catch unreachable;
    cflags.append("-Wall") catch unreachable;
    cflags.append("-O2") catch unreachable;
    cflags.append("-fvisibility=hidden") catch unreachable;
    cflags.append("-fpic") catch unreachable;
    cflags.append("-D_XOPEN_SOURCE=700") catch unreachable;  // Needed? Maybe 600?

    // Platform specific build options. These dont seem to do anything at the moment?
    const target_os = target.query.os_tag;
    if (target_os == .macos) {
        std.debug.print("Building for macOS\n", .{});
        cflags.append("-dynamiclib") catch unreachable;
    } else if (target_os == .linux) {
        std.debug.print("Building for Linux\n", .{});
        cflags.append("-shared") catch unreachable;
        cflags.append("-Wl") catch unreachable;
        const soname = std.fmt.allocPrint(arena, "-Wl,-soname,libhts.so.{}", .{LIBHTS_SOVERSION}) catch unreachable;
        defer arena.free(soname);
        cflags.append(soname) catch unreachable;
    }

    // const htslib = b.addStaticLibrary(.{
    const htslib = b.addSharedLibrary(.{
        .name = "hts",
        .target = target,
        .optimize = optimize,
    });

    const src_files = &[_][]const u8{
        "htslib/kfunc.c",
        "htslib/kstring.c",
        "htslib/bcf_sr_sort.c",
        "htslib/bgzf.c",
        "htslib/errmod.c",
        "htslib/faidx.c",
        "htslib/header.c",
        "htslib/hfile.c",
        "htslib/hts.c",
        "htslib/hts_expr.c",
        "htslib/hts_os.c",
        "htslib/md5.c",
        "htslib/multipart.c",
        "htslib/probaln.c",
        "htslib/realn.c",
        "htslib/regidx.c",
        "htslib/region.c",
        "htslib/sam.c",
        "htslib/sam_mods.c",
        "htslib/synced_bcf_reader.c",
        "htslib/vcf_sweep.c",
        "htslib/tbx.c",
        "htslib/textutils.c",
        "htslib/thread_pool.c",
        "htslib/vcf.c",
        "htslib/vcfutils.c",
        "htslib/cram/cram_codecs.c",
        "htslib/cram/cram_decode.c",
        "htslib/cram/cram_encode.c",
        "htslib/cram/cram_external.c",
        "htslib/cram/cram_index.c",
        "htslib/cram/cram_io.c",
        "htslib/cram/cram_stats.c",
        "htslib/cram/mFILE.c",
        "htslib/cram/open_trace_file.c",
        "htslib/cram/pooled_alloc.c",
        "htslib/cram/string_alloc.c",
        "htslib/htscodecs/htscodecs/arith_dynamic.c",
        "htslib/htscodecs/htscodecs/fqzcomp_qual.c",
        "htslib/htscodecs/htscodecs/htscodecs.c",
        "htslib/htscodecs/htscodecs/pack.c",
        "htslib/htscodecs/htscodecs/rANS_static4x16pr.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_avx2.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_avx512.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_sse4.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_neon.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr.c",
        "htslib/htscodecs/htscodecs/rANS_static.c",
        "htslib/htscodecs/htscodecs/rle.c",
        "htslib/htscodecs/htscodecs/tokenise_name3.c",
        "htslib/htscodecs/htscodecs/utils.c",
        "htslib/hfile_libcurl.c",
    };

    for (src_files) |file| {
        htslib.addCSourceFile(.{
            .file = .{.path = file},
            .flags = cflags.items,
        });
    }

    var self_exe_dir_path: []const u8 = std.fs.selfExeDirPathAlloc(arena) catch unreachable;

    htslib.addIncludePath(.{ .path = self_exe_dir_path });

    generateHeaders(b, &self_exe_dir_path);

    htslib.addIncludePath(.{ .path = "htslib" });
    htslib.addIncludePath(.{ .path = "htslib/cram" });
    htslib.addIncludePath(.{ .path = "htslib/htscodecs/htscodecs" });
    htslib.addIncludePath(.{ .path = "htslib/htslib" });
    htslib.addIncludePath(.{ .path = "htslib/os" });

    htslib.linkLibC();

    htslib.linkSystemLibrary("z");
    htslib.linkSystemLibrary("m");
    htslib.linkSystemLibrary("bz2");
    htslib.linkSystemLibrary("lzma");
    htslib.linkSystemLibrary("curl");
    htslib.linkSystemLibrary("pthread");

    b.default_step.dependOn(&htslib.step);
    b.installArtifact(htslib);

    const zights = b.addModule("zights", .{ .root_source_file = .{ .path = "src/zights.zig" } });

    zights.addIncludePath(.{ .path = "htslib" });
    zights.addIncludePath(.{ .path = "htslib/htslib" });
    zights.addIncludePath(.{ .path = "htslib/cram" });
    zights.linkLibrary(htslib);

}
