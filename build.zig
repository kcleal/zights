
const std = @import("std");


pub fn generateHeaders(b: *std.Build, build_path: *[]const u8) void {
    var buf: [std.fs.MAX_PATH_BYTES]u8 = undefined;
    std.mem.copyForwards(u8, buf[0..], build_path.*);
    std.debug.print("Saving headers in {s}\n", .{buf[0..build_path.len]});

    //config.h
    var hdr_path: []const u8 = "/config.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genConfigFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    defer genConfigFile.close();
    const writer = genConfigFile.writer();
    writer.print(
    \\ /* Default config.h generated by build.zig */
    \\#define HAVE_LIBBZ2 1
    \\#define HAVE_LIBLZMA 1
    \\#ifndef __APPLE__
    \\#define HAVE_LZMA_H 1
    \\#endif
    \\#define HAVE_DRAND48 1
    \\#define HAVE_LIBCURL 1
    \\#define HAVE_POPCNT 1
    \\#define HAVE_SSE4_1 1
    \\#define HAVE_SSSE3 1
    \\#define HAVE_AVX2 1
    \\#define HAVE_AVX512 1
    \\#define UBSAN 1
    , .{}) catch unreachable;

    //config_vars.h
    hdr_path = "/config_vars.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genVarsFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    const vars_writer = genVarsFile.writer();
    const CPPFLAGS: []const u8 = b.graph.env_map.get("CPPFLAGS") orelse "";
    const CFLAGS: []const u8 = b.graph.env_map.get("CFLAGS") orelse "";
    const LDFLAGS: []const u8 = b.graph.env_map.get("LDFLAGS") orelse "";
    const LIBS: []const u8 = b.graph.env_map.get("LIBS") orelse "";
    vars_writer.print(
    \\#define HTS_CC "zig cc"
    \\#define HTS_CPPFLAGS "{s}"
    \\#define HTS_CFLAGS "{s} -g -Wall -O2 -fvisibility=hidden -fpic"
    \\#define HTS_LDFLAGS "{s} -fvisibility=hidden "
    \\#define HTS_LIBS "{s} -lz -lm -lbz2 -llzma -lcurl -lpthread"
    , .{CPPFLAGS, CFLAGS, LDFLAGS, LIBS}) catch unreachable;

    // version.h
    const hts_version = "1.19.1";
    hdr_path = "/version.h";
    std.mem.copyForwards(u8, buf[build_path.len..], hdr_path);
    var genVerFile = std.fs.createFileAbsolute(buf[0..build_path.len + hdr_path.len], .{ .truncate = true }) catch unreachable;
    const ver_writer = genVerFile.writer();
    ver_writer.print(
    \\#define HTS_VERSION_TEXT "{s}"
    , .{hts_version}) catch unreachable;
}

pub fn build(b: *std.Build) void {

    const LIBHTS_SOVERSION = 3;

    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{ .preferred_optimize_mode = std.builtin.OptimizeMode.ReleaseFast });

    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();
    const arena = arena_state.allocator();

    var cflags = std.ArrayList([]const u8).init(arena);
    defer cflags.deinit();

    cflags.append("-g") catch unreachable;
    cflags.append("-Wall") catch unreachable;
    cflags.append("-O2") catch unreachable;
    cflags.append("-fvisibility=hidden") catch unreachable;
    cflags.append("-fpic") catch unreachable;
    cflags.append("-D_XOPEN_SOURCE=700") catch unreachable;  // Needed? Maybe 600?

    // Platform specific build options
    const target_os = target.query.os_tag;

    if (target_os == .macos) {
        std.debug.print("Building for macOS\n", .{});
        cflags.append("-dynamiclib") catch unreachable;
    } else if (target_os == .linux) {
        std.debug.print("Building for Linux\n", .{});
        cflags.append("-shared") catch unreachable;
        cflags.append("-Wl") catch unreachable;
        const soname = std.fmt.allocPrint(arena, "-Wl,-soname,libhts.so.{}", .{LIBHTS_SOVERSION}) catch unreachable;
        defer arena.free(soname);
        cflags.append(soname) catch unreachable;
    }

    // const htslib = b.addStaticLibrary(.{
    const htslib = b.addSharedLibrary(.{
        .name = "hts",
        .target = target,
        .optimize = optimize,
    });

    const src_files = &[_][]const u8{
        "htslib/kfunc.c",
        "htslib/kstring.c",
        "htslib/bcf_sr_sort.c",
        "htslib/bgzf.c",
        "htslib/errmod.c",
        "htslib/faidx.c",
        "htslib/header.c",
        "htslib/hfile.c",
        "htslib/hts.c",
        "htslib/hts_expr.c",
        "htslib/hts_os.c",
        "htslib/md5.c",
        "htslib/multipart.c",
        "htslib/probaln.c",
        "htslib/realn.c",
        "htslib/regidx.c",
        "htslib/region.c",
        "htslib/sam.c",
        "htslib/sam_mods.c",
        "htslib/synced_bcf_reader.c",
        "htslib/vcf_sweep.c",
        "htslib/tbx.c",
        "htslib/textutils.c",
        "htslib/thread_pool.c",
        "htslib/vcf.c",
        "htslib/vcfutils.c",
        "htslib/cram/cram_codecs.c",
        "htslib/cram/cram_decode.c",
        "htslib/cram/cram_encode.c",
        "htslib/cram/cram_external.c",
        "htslib/cram/cram_index.c",
        "htslib/cram/cram_io.c",
        "htslib/cram/cram_stats.c",
        "htslib/cram/mFILE.c",
        "htslib/cram/open_trace_file.c",
        "htslib/cram/pooled_alloc.c",
        "htslib/cram/string_alloc.c",
        "htslib/htscodecs/htscodecs/arith_dynamic.c",
        "htslib/htscodecs/htscodecs/fqzcomp_qual.c",
        "htslib/htscodecs/htscodecs/htscodecs.c",
        "htslib/htscodecs/htscodecs/pack.c",
        "htslib/htscodecs/htscodecs/rANS_static4x16pr.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_avx2.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_avx512.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_sse4.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr_neon.c",
        "htslib/htscodecs/htscodecs/rANS_static32x16pr.c",
        "htslib/htscodecs/htscodecs/rANS_static.c",
        "htslib/htscodecs/htscodecs/rle.c",
        "htslib/htscodecs/htscodecs/tokenise_name3.c",
        "htslib/htscodecs/htscodecs/utils.c",
        "htslib/hfile_libcurl.c",
    };

    for (src_files) |file| {
        htslib.addCSourceFile(.{
            .file = .{.path = file},
            .flags = cflags.items,
        });
    }

    var self_exe_dir_path: []const u8 = std.fs.selfExeDirPathAlloc(arena) catch unreachable;

    htslib.addIncludePath(.{ .path = self_exe_dir_path });

    generateHeaders(b, &self_exe_dir_path);

    htslib.addIncludePath(.{ .path = "htslib" });
    htslib.addIncludePath(.{ .path = "htslib/cram" });
    htslib.addIncludePath(.{ .path = "htslib/htscodecs/htscodecs" });
    htslib.addIncludePath(.{ .path = "htslib/htslib" });
    htslib.addIncludePath(.{ .path = "htslib/os" });

    htslib.linkLibC();

    htslib.linkSystemLibrary("z");
    htslib.linkSystemLibrary("m");
    htslib.linkSystemLibrary("bz2");
    htslib.linkSystemLibrary("lzma");
    htslib.linkSystemLibrary("curl");
    htslib.linkSystemLibrary("pthread");


    b.default_step.dependOn(&htslib.step);
    b.installArtifact(htslib);

    const zights = b.addModule("zights", .{ .root_source_file = .{ .path = "src/zights.zig" } });

    zights.addIncludePath(.{ .path = "htslib" });
    zights.addIncludePath(.{ .path = "htslib/htslib" });
    zights.addIncludePath(.{ .path = "htslib/cram" });
    zights.linkLibrary(htslib);

}
